#!/usr/bin/env node

import fs from "fs";
import chalk from "chalk";
import {
  DAISY_COLORS,
  DAISY_SIZES,
  DAISY_VARIANTS,
  DAISY_SHAPES,
  COMPONENT_CAPABILITIES,
  ComponentCapability,
  DAISY_COMPONENTS,
} from "./daisy-meta.ts";

/**
 * @file generate-daisy-safelist.ts
 * @description Automatically generates a CSS safelist for DaisyUI components based on metadata.
 *
 * LLM AGENT INSTRUCTIONS:
 * This script runs to generate `src/app/styles/daisy-safelist.css`.
 * It prevents the Tailwind compiler from tree-shaking dynamic classes generated by your React components.
 *
 * IF YOU ADD A NEW CAPABILITY MODIFIER TO `daisy-meta.ts` (e.g. "shadow" or "border"),
 * you MUST update `buildClassList()` in this script to iterate over the new capability and generate
 * the respective CSS classes. Otherwise, dynamically constructed classes will be purged in production!
 */

/**
 * Extracts normalized capabilities for a given DaisyUI component, defaulting missing properties to safe values.
 */
function resolvedCaps(component: string): ComponentCapability {
  const caps =
    COMPONENT_CAPABILITIES[component as keyof typeof COMPONENT_CAPABILITIES];

  return {
    colors: caps?.colors === true,
    sizes: caps?.sizes === true,
    variants: caps?.variants ?? [],
    shapes: caps?.shapes === true,
    activity: caps?.activity === true,
    orientation: caps?.orientation === true,
    placement: caps?.placement ?? [],
    alignment: caps?.alignment ?? [],
  };
}

/**
 * Iterates across all defined `COMPONENT_CAPABILITIES` and constructs an array of literally
 * typed CSS classes that DaisyUI supports (e.g. `btn-primary`, `btn-sm`, `badge-outline`).
 * Returns an alphabetically sorted array of unique class names.
 */
function buildClassList(): string[] {
  const classes: string[] = [];

  for (const comp of DAISY_COMPONENTS) {
    const caps = resolvedCaps(comp);

    if (caps.colors) {
      for (const c of DAISY_COLORS) {
        classes.push(`${comp}-${c}`);
      }
    }

    if (caps.sizes) {
      for (const s of DAISY_SIZES) {
        classes.push(`${comp}-${s}`);
      }
    }

    if (caps.variants) {
      if (Array.isArray(caps.variants)) {
        for (const v of caps.variants) {
          classes.push(`${comp}-${v}`);
        }
      } else if (caps.variants === true) {
        for (const v of DAISY_VARIANTS) {
          classes.push(`${comp}-${v}`);
        }
      }
    }

    if (caps.shapes) {
      for (const sh of DAISY_SHAPES) {
        classes.push(`${comp}-${sh}`);
      }
    }

    if (caps.activity) {
      classes.push(comp, `${comp}-active`, `${comp}-disabled`);
    }

    if (caps.orientation) {
      classes.push(`${comp}-horizontal`, `${comp}-vertical`);
    }

    if (caps.placement?.length) {
      for (const p of caps.placement) {
        classes.push(`${comp}-${p}`);
      }
    }

    if (caps.alignment?.length) {
      for (const a of caps.alignment) {
        classes.push(`${comp}-${a}`);
      }
    }
  }

  const unique = Array.from(new Set(classes));
  unique.sort();
  return unique;
}

/**
 * Writes the dynamically generated class list to a CSS file using the Tailwind `@source` directive.
 * The generated file serves as a global class registry that Tailwind force-includes into the bundle.
 */
function emitFile(list: string[]): void {
  const outPath = "src/app/styles/daisy-safelist.css";
  const fileContents = `/* AUTO-GENERATED. DO NOT EDIT MANUALLY. */
  @source inline("${list.join(" ")}");
`;

  try {
    fs.writeFileSync(outPath, fileContents);
    console.log(
      `${chalk.green("✔")} ${chalk.bold("Generated")} ` +
        `${chalk.cyan(outPath)} ${chalk.grey("with")} ` +
        `${chalk.yellow(list.length.toString())} ${chalk.grey("classes.")}`,
    );
  } catch (err: any) {
    console.error(
      `${chalk.red("✖")} ${chalk.bold.red("Failed to write")} ` +
        `${chalk.cyan(outPath)}: ${chalk.red(err.message)}`,
    );
    process.exit(1);
  }
}

function main(): void {
  try {
    const list = buildClassList();
    emitFile(list);
  } catch (err: any) {
    console.error(
      `${chalk.red("✖")} ${chalk.bold.red("Error:")} ${chalk.red(err.message)}`,
    );
    process.exit(1);
  }
}

main();
